namespace Logging
{
	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Diagnostics;
	using System.Globalization;
	using System.IO;
	using System.Reflection;
	using System.Runtime.CompilerServices;
	using System.Security;
	using System.Text;
	using System.Threading;
	
    static class EventHandlerExtentions
    {
        /// <summary>
        /// Safely invoke an event handler with a deferred event data building
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event, must be System.EventArgs</typeparam>
        /// <param name="ev">The method that will handle the event</param>
        /// <param name="sender">The source of the event</param>
        /// <param name="getArguments">The delegate that builds the event data</param>
        public static void SafeInvoke<TEventArgs>(this EventHandler<TEventArgs> ev, object sender, Func<TEventArgs> getArguments) where TEventArgs : EventArgs
        {
            //since delegates are immutable than we are safe just to check for null before invocation
            if (ev != null)
            {
                ev(sender, getArguments());
            }
        }
    }

	public sealed class RILCommonDebug
	{
		#region Constants
		private const int MESSAGE_NUM = 1000;
		private const int ERROR_NUM = 1000;
		public const char DELIMETER = '\u00A0';
		private const string UNKNOWN_LEVEL = "Unknown(1)";
		private const string UNKNOWN_METHOD = "Unknown(3)";
		private const string UNKNOWN_ERROR = "Unknown(2)";
		private const string LOG_NAME = "Axtrax.NET";
		private const string LOG_APPLICATION = "Application";
		private const string DATE_TIME_FORMAT = "dd.MM.yyyy HH:mm:ss.FFF";
		private static string ProcName = null;
		#endregion

		#region Variables

		private readonly Queue<string> lstMessages = new Queue<string>(MESSAGE_NUM);
		private readonly Queue<string> lstErrors = new Queue<string>(ERROR_NUM);
		#endregion

		public event EventHandler<string> MessageAdded;
        public event EventHandler<string> ErrorAdded;

		private static readonly RILCommonDebug instance = new RILCommonDebug();
		public static RILCommonDebug Instance
		{
			get { return instance; }
		}
		#region Constructors
		private RILCommonDebug()
		{
			Debug.AutoFlush = true;
			Trace.AutoFlush = true;
			string cli = "client";
			string ser = "server";
            string watch = "server monitor";
			string pName = System.Diagnostics.Process.GetCurrentProcess().ProcessName;
			if(pName.ToLower().Contains(cli))
			{
				ProcName = "NG Client";
			}
            else if (pName.ToLower().Contains(watch))
            {
                ProcName = "NG Server Monitor";
            }
			else if(pName.ToLower().Contains(ser))
			{
				ProcName = "NG Server";
			}
			else
			{
                ProcName = pName;
			}
		}
		#endregion

		#region Properties
		public string[] Messages
		{
			get
			{
				return lstMessages.ToArray();
			}
		}

		public string[] Errors
		{
			get
			{
				return lstErrors.ToArray();
			}
		}

		public static bool ErrorsOnly
		{
			get;
			set;
		}
		#endregion

		#region Public functions
		public static MethodBase GetCallerMethod(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);
				if(level < st.FrameCount)
				{
					StackFrame sf = st.GetFrame(level);
					return sf.GetMethod();
				}
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
			}
			return null;
		}

		public static string GetCallerLocation(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);

				if(level >= st.FrameCount)
				{
					return UNKNOWN_LEVEL;
				}

				StackFrame sf = st.GetFrame(level);
				string loc = sf.GetFileName();
				if(loc != null)
				{
					loc = loc.Substring(loc.LastIndexOf("\\", StringComparison.Ordinal) + 1);
					return loc + "(" + sf.GetFileLineNumber() + ")";
				}
				MethodBase met = sf.GetMethod();
				return met != null ? met.ReflectedType.Name + "." + met.Name : UNKNOWN_METHOD;
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return UNKNOWN_ERROR;
			}
		}

		public static string[] GetCallerLocationAsStringArr(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);

				if(level >= st.FrameCount)
				{
					return new string[] { UNKNOWN_LEVEL, "" };
				}

				StackFrame sf = st.GetFrame(level);
				string loc = sf.GetFileName();
				if(loc != null)
				{
					loc = loc.Substring(loc.LastIndexOf("\\", StringComparison.Ordinal) + 1);
					return new string[] { loc, sf.GetFileLineNumber().ToString() };
				}
				MethodBase met = sf.GetMethod();
				return new string[] { met != null ? met.ReflectedType.Name + "." + met.Name : UNKNOWN_METHOD, "" };
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return new string[] { UNKNOWN_ERROR, "" };
			}
		}

		public static int GetCallerLine(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);

				if(level < st.FrameCount)
				{
					StackFrame sf = st.GetFrame(level);
					if(sf.GetFileName() != string.Empty)
					{
						return sf.GetFileLineNumber();
					}
				}
				return 0;
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return 0;
			}
		}

		public static string GetCallerFunction(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);

				if(level >= st.FrameCount)
				{
					return UNKNOWN_LEVEL;
				}

				StackFrame sf = st.GetFrame(level);
				MethodBase met = sf.GetMethod();
				return met != null ? met.ReflectedType.Name + "." + met.Name : UNKNOWN_METHOD;
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return UNKNOWN_ERROR;
			}
		}

		public static string GetCallStack(int level = 1)
		{
			try
			{
				StackTrace st = new StackTrace(true);
				StringBuilder sb = new StringBuilder();
				for(int i = level; i < st.FrameCount; i++)
				{
					StackFrame sf = st.GetFrame(i);
					MethodBase met = sf.GetMethod();
					if(met != null)
					{
						sb.AppendFormat("{0}.{1};", met.ReflectedType.Name, met.Name);
					}
					else
					{
						sb.AppendFormat("{0};", UNKNOWN_METHOD);
					}
				}
				return sb.ToString();
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return UNKNOWN_ERROR;
			}
		}

		public static string GetCallerName(int level)
		{
			try
			{
				StackTrace st = new StackTrace(true);
				if(level >= st.FrameCount)
				{
					return UNKNOWN_LEVEL;
				}

				StackFrame sf = st.GetFrame(level);
				return sf.GetMethod().Name;
			}
			catch(Exception ex)
			{
				Debug.WriteLine(ex.ToString());
				return UNKNOWN_ERROR;
			}
		}

		#region 825 Logs

		public static void Write825Trace(
			string locationInFlow,
			bool callstack = false,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string filePath = "",
			[CallerLineNumber] int lineNumber = 0)
		{
#if PORT_LISTNER_LOG
			string msg = string.Format("{0} - {1} : {2}\r\n************************\r\n", DateTime.Now, locationInFlow, , callstack ? GetCallStack(2) : string.Empty);
			DBG(msg, false, memberName, filePath, lineNumber);
#endif
		}

		public static void Write825Trace(
			string locationInFlow,
			string message,
			bool callstack = false,
			 [CallerMemberName] string memberName = "",
			 [CallerFilePath] string filePath = "",
			 [CallerLineNumber] int lineNumber = 0)
		{

#if PORT_LISTNER_LOG
			string msg = string.Format("{0} - {1}. Message Sent IS: {2} :\r\n {3}\r\n************************\r\n", DateTime.Now, locationInFlow, message, callstack ? GetCallStack(2) : string.Empty);
			DBG(msg, false, memberName, filePath, lineNumber);
#endif
		}

		public static void Write825Trace(
			string locationInFlow,
			Exception error,
			bool callstack = false,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string filePath = "",
			[CallerLineNumber] int lineNumber = 0)
		{
#if PORT_LISTNER_LOGs
			string msg = string.Format("{0} - {1}. Error IS: {2} :\r\n {3}\r\n************************\r\n", DateTime.Now, locationInFlow, error, , callstack ? GetCallStack(2) : string.Empty);
			DBG(msg, false, memberName, filePath, lineNumber);
#endif
		}

		#endregion

        public const string _825Perfix = "osdp";
        public const string _ProtTracReadFlag = "*****************************";
        public const string _ProtTracNoDate = "ProtTracNoDate";
        public const string _ProtocolTracing = "ProtocolTracing";

        public static string ConvertCommand(byte[] _command)// to do : osdp
        {
            StringBuilder sb = new StringBuilder();
            for (int ii = 0; ii < _command.Length; ii++)
            {
                sb.Append(_command[ii].ToString("X"));
                sb.Append(" , ");
            }
            string command = sb.ToString();
            return command;
        }


        public static bool IsProtcolTracingEnable()
        {
            bool bProtcolTracing = false;

#if ProtocolTracing
            bProtcolTracing = true;
#endif

            return bProtcolTracing;
        }

        public static void ProtocolTracing(List<string> traceMessages)
        {
#if ProtocolTracing
            foreach (var message in traceMessages)
            {
                Debug.WriteLine(message);
                Instance.SendMessage(message);
            }
#endif
        }


        public static void ProtocolTracing(string msg)
        {
#if ProtocolTracing
            if (msg.Contains(_ProtTracNoDate))
            {
                msg = msg.Remove(msg.IndexOf(_ProtTracNoDate), _ProtTracNoDate.Length);
                msg = _ProtocolTracing + "       " + msg;
            }
            else
            {
                msg = _ProtocolTracing + DateTime.Now.ToString() + ": " + msg;
            }
            Debug.WriteLine(msg);
             Instance.SendMessage(msg);
#endif
        }

		public static void DBG(
			string msg,
			bool writetolog = false,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string filePath = "",
			[CallerLineNumber] int lineNumber = 0)
		{
            if(msg == null)
            {
                return;
            }
 #if !ProtocolTracing
			if(!ErrorsOnly)
			{
				try
				{
                    //todo : this prefix will stay until version will be very stable
                    if (msg.StartsWith(_825Perfix))
                    {
                        return;
                    }

                    //string msg = msgg.Remove(0, 4);
					StringBuilder cache = new StringBuilder();

					cache.AppendFormat("{1}({2}):{0}{3}", DELIMETER, Path.GetFileName(filePath), lineNumber, memberName);

					cache.AppendFormat("{0}{1}{0}({2} {3} {4}){0}",
						DELIMETER, DateTime.Now.ToString(DATE_TIME_FORMAT),
						Thread.CurrentThread.ManagedThreadId.ToString(CultureInfo.InvariantCulture), Thread.CurrentThread.Name ?? "NO-NAME", Thread.CurrentThread.Priority);

					cache.Append(msg);

					string message = cache.ToString();

					Debug.WriteLine(message);

					if(writetolog)
					{
						WriteToEventLog(message, EventLogEntryType.Information, lineNumber);
					}

					Instance.SendMessage(message);
				}
				catch(Exception)
				{
				}
			}
#endif
        }

		public static void ErrorLog(
			Exception ex,
			bool sendToComm = true,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string filePath = "",
			[CallerLineNumber] int lineNumber = 0)
		{
			try
			{
                if(ex == null)
                {
                    return;
                }

				Type exceptionType = ex.GetType();

				StringBuilder cache = new StringBuilder();

				cache.AppendLine();
				cache.AppendFormat("{0} {1} {0}", "-".PadLeft(20, '-'), exceptionType);
				cache.AppendLine();

				cache.AppendFormat("{1}({2}):{0}{3}", DELIMETER, Path.GetFileName(filePath), lineNumber, memberName);

				cache.AppendFormat("{0}{1}{0}({2} {3} {4}){0}",
					DELIMETER, DateTime.Now.ToString(DATE_TIME_FORMAT),
					Thread.CurrentThread.ManagedThreadId.ToString(CultureInfo.InvariantCulture), Thread.CurrentThread.Name ?? "NO-NAME", Thread.CurrentThread.Priority);

				cache.AppendFormat("{1}{0}{2}{0}", DELIMETER, exceptionType, ex.Message);

				cache.AppendLine(ex.StackTrace);

				cache.AppendLine();
				cache.AppendFormat("{0} {1} {0}", "-".PadLeft(20, '-'), exceptionType);
				cache.AppendLine();

				string message = cache.ToString();

				Trace.WriteLine(message);

				WriteToEventLog(message, EventLogEntryType.Error, lineNumber);

				if(sendToComm)
				{
					Instance.SendError(message);
				}
			}
			catch(Exception)
			{
			}
		}

		public static int GetInstanceCount()
		{
			using(Process p = Process.GetCurrentProcess())
			{
				Process[] ps = Process.GetProcessesByName(p.ProcessName);
				return ps.Length;
			}
		}
		#endregion

		#region Private functions
		private static void WriteToEventLog(string finalmsg, EventLogEntryType type, int callerline)
		{
			try
			{
				if(!EventLog.SourceExists(ProcName))
				{
					EventLog.CreateEventSource(ProcName, LOG_APPLICATION);
				}
				EventLog.WriteEntry(ProcName, finalmsg, type, callerline);
			}
			catch(Win32Exception)
			{
				try
				{
					(new EventLog
					{
						Log = LOG_APPLICATION
					}).Clear();
				}
				catch
				{
				}
			}
			catch(SecurityException)
			{
				try
				{
					EventLog.CreateEventSource(LOG_NAME, LOG_APPLICATION);
					EventLog.WriteEntry(LOG_NAME, finalmsg, type, callerline);
				}
				catch
				{
				}
			}
			catch
			{
			}
		}

		private void SendMessage(string finalmsg)
		{
			lock(lstMessages)
			{
				if(lstMessages.Count >= MESSAGE_NUM)
				{
					lstMessages.Dequeue();
				}
				lstMessages.Enqueue(finalmsg);
			}
			//MessageAdded.SafeInvoke(null, () => { return new MessageEventArgs(finalmsg); });
            if(MessageAdded != null)
            {
                MessageAdded(null, finalmsg);
            }
		}

		private void SendError(string finalmsg)
		{
			lock(lstErrors)
			{
				if(lstErrors.Count >= ERROR_NUM)
				{
					lstErrors.Dequeue();
				}
				lstErrors.Enqueue(finalmsg);
			}
			//ErrorAdded.SafeInvoke(null, () => { return new MessageEventArgs(finalmsg); });
            if(ErrorAdded != null)
            {
                ErrorAdded(null, finalmsg);
            }
           
		}
		#endregion
	}

    //[Serializable]
    //public abstract class BaseMessage<TMessage>
    //{
    //    #region Constants
    //    protected const char DELIMETER = '\u00A0';
    //    private const string DATE_TIME_FORMAT = "dd.MM.yyyy HH:mm:ss.FFF";
    //    #endregion

    //    #region Properties
    //    public string LocationFile
    //    {
    //        get;
    //        set;
    //    }

    //    public string LocationLine
    //    {
    //        get;
    //        set;
    //    }

    //    public string Function
    //    {
    //        get;
    //        set;
    //    }

    //    public DateTime MesageDate
    //    {
    //        get;
    //        set;
    //    }

    //    public string ThreadName
    //    {
    //        get;
    //        set;
    //    }

    //    public int ThreadPriority
    //    {
    //        get;
    //        set;
    //    }

    //    public TMessage Message
    //    {
    //        get;
    //        set;
    //    }
    //    #endregion

    //    #region Protected functions
    //    protected abstract string MessageToString();
    //    #endregion

    //    #region Public functions
    //    public new string ToString()
    //    {
    //        StringBuilder cache = new StringBuilder();
    //        cache.Append(LocationFile);
    //        if(!string.IsNullOrEmpty(LocationLine))
    //        {
    //            cache.Append("(");
    //            cache.Append(LocationLine);
    //            cache.Append(")");
    //        }
    //        cache.Append(":");
    //        cache.Append(DELIMETER);
    //        cache.Append(Function);
    //        cache.Append(DELIMETER);
    //        cache.Append(MesageDate.ToString(DATE_TIME_FORMAT));
    //        cache.Append(DELIMETER);
    //        cache.Append("(");
    //        if(!string.IsNullOrEmpty(ThreadName))
    //        {
    //            cache.Append(ThreadName);
    //            cache.Append(" ");
    //        }
    //        cache.Append(ThreadPriority);
    //        cache.Append(")");
    //        cache.Append(DELIMETER);
    //        cache.Append(MessageToString());

    //        return cache.ToString();
    //    }
    //    #endregion
    //}

    //[Serializable]
    //public class TextMessage : BaseMessage<string>
    //{
    //    #region Protected functions
    //    protected override string MessageToString()
    //    {
    //        return Message;
    //    }
    //    #endregion
    //}

    //[Serializable]
    //public class ErrorMessage : BaseMessage<Exception>
    //{
    //    #region Properties
    //    public string CallStack
    //    {
    //        get;
    //        set;
    //    }
    //    #endregion

    //    #region Protected functions
    //    protected override string MessageToString()
    //    {
    //        return Message.GetType().ToString() + DELIMETER + Message.Message + DELIMETER + CallStack;
    //    }
    //    #endregion
    //}


}